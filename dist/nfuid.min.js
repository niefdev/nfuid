class NFUID{#BASE_ALPHABET;#BASE_MAP;#timestampBits;#randomBits;#baseRadix;constructor({baseAlphabet="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",timestampLength=32,entropyLength=96}={}){if(!/^[\x21-\x7E]+$/.test(baseAlphabet)||baseAlphabet.includes(" ")){throw new Error("Base alphabet must contain only valid ASCII characters without whitespace")}if(new Set(baseAlphabet.split("")).size!==baseAlphabet.length){throw new Error("Base alphabet must not contain duplicate characters")}if(timestampLength<0||timestampLength>63){throw new Error("Timestamp length must be between 0 and 63 bits")}if(entropyLength<6+timestampLength){throw new Error(`Entropy length must be at least ${6+timestampLength} bits (timestamp + 6 bits)`)}this.#BASE_ALPHABET=baseAlphabet;this.#baseRadix=BigInt(baseAlphabet.length);this.#timestampBits=timestampLength;this.#randomBits=entropyLength;this.#BASE_MAP={};for(let i=0;i<this.#BASE_ALPHABET.length;i++){this.#BASE_MAP[this.#BASE_ALPHABET[i]]=BigInt(i)}}#toBase(num,minLength=0){if(num===0n){return this.#BASE_ALPHABET[0].repeat(minLength||1)}let result="";let n=num;while(n>0n){const rem=n%this.#baseRadix;n=n/this.#baseRadix;result=this.#BASE_ALPHABET[Number(rem)]+result}while(result.length<minLength){result=this.#BASE_ALPHABET[0]+result}return result}#fromBase(str){let result=0n;for(const char of str){const value=this.#BASE_MAP[char];if(value===undefined){throw new Error(`Invalid character in encoded string: ${char}`)}result=result*this.#baseRadix+value}return result}#generateRandomBits(bits){const bytes=Math.ceil(bits/8);const buffer=new Uint8Array(bytes);crypto.getRandomValues(buffer);let value=0n;for(const byte of buffer){value=value<<8n|BigInt(byte)}return value&(1n<<BigInt(bits))-1n}generate(){const headerBits=6;const header=BigInt(this.#timestampBits);const timestampMask=(1n<<BigInt(this.#timestampBits))-1n;const timestamp=this.#timestampBits>0?BigInt(Math.floor(Date.now()/1e3))&timestampMask:0n;const randBits=this.#generateRandomBits(this.#randomBits);let finalHeader=header;let finalTimestamp=timestamp;const headerXorMask=randBits&(1n<<BigInt(headerBits))-1n;finalHeader=header^headerXorMask;if(this.#timestampBits>0){const timestampXorMask=randBits>>BigInt(this.#randomBits-this.#timestampBits);finalTimestamp=timestamp^timestampXorMask}let finalValue=1n;finalValue=finalValue<<BigInt(headerBits)|finalHeader;if(this.#timestampBits>0){finalValue=finalValue<<BigInt(this.#timestampBits)|finalTimestamp}finalValue=finalValue<<BigInt(this.#randomBits)|randBits;const totalBits=BigInt(1+headerBits+this.#timestampBits+this.#randomBits);const bitsPerChar=Math.log2(this.#BASE_ALPHABET.length);const minLength=Math.ceil(Number(totalBits)/bitsPerChar);return this.#toBase(finalValue,minLength)}decode(id){const full=this.#fromBase(id);const binary=full.toString(2).slice(1);const fullLength=binary.length;const value=full^1n<<BigInt(fullLength);const headerBits=6;const headerMask=(1n<<BigInt(headerBits))-1n;const headerShift=BigInt(fullLength-headerBits);const encodedHeader=value>>headerShift&headerMask;const headerXorMask=value&headerMask;const actualTimestampBits=Number(encodedHeader^headerXorMask);const randomBitsLength=fullLength-headerBits-actualTimestampBits;const randomMask=(1n<<BigInt(randomBitsLength))-1n;const encodedRandom=value&randomMask;const result={timestampLength:actualTimestampBits,timestamp:0,randomLength:Number(randomBitsLength),random:encodedRandom.toString(16),formattedTimestamp:null,binary:binary};if(actualTimestampBits>0){const timestampShift=BigInt(randomBitsLength);const timestampMask=(1n<<BigInt(actualTimestampBits))-1n;const encodedTimestamp=value>>timestampShift&timestampMask;const timestampXorMask=encodedRandom>>BigInt(randomBitsLength-actualTimestampBits);const actualTimestamp=encodedTimestamp^timestampXorMask;result.timestamp=Number(actualTimestamp);result.formattedTimestamp=new Date(Number(actualTimestamp)*1e3)}return result}}module.exports=NFUID;